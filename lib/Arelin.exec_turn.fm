Arelin.exec_turn(gm: Arelin.Game): Arelin.Game
  // Interaction function
  let intr = ((that) (this) 
   Arelin.interact_with(this, that)
  ) :: Arelin.Thing -> Arelin.Thing -> Arelin.Thing 
  // For each thing in the game...
  let tick = ((this) (others) (res)
    // Removes past hits
    let this = Arelin.Thing.set_hit(this, List.nil<>)
    // Resets   
    let rst = Arelin.Thing.get_rst(this)
    let this = 
      case rst:
      | #true#
        let new_vel = F64.V3.new(F64.0,F64.0,F64.0)
        let new_bst = F64.1
        let new_box = Arelin.Game.Hitbox.cbox(F64.mul(F64.parse("3"), F64.parse("4")))
        let new_act = F64.0
        let new_tik = F64.0
        let new_lit = List.nil<Arelin.Game.Light>
        let new_rst = Bool.false 
        let this = Arelin.Thing.set_vel(this, new_vel)
        let this = Arelin.Thing.set_bst(this, new_bst)
        let this = Arelin.Thing.set_box(this, new_box)
        let this = Arelin.Thing.set_act(this, new_act)
        let this = Arelin.Thing.set_tik(this, new_tik)
        let this = Arelin.Thing.set_lit(this, new_lit)
        let this = Arelin.Thing.set_rst(this, new_rst)
        this;
      | #false# this;  
    // Integrates position with walk vector
    let boost = Arelin.Thing.speed_multiplier_of(this)
    let pos   = Arelin.Thing.get_pos(this)
    let mov   = Arelin.Thing.get_mov(this)
    let pad   = Arelin.Thing.get_pad(this)
    let this  = 
      Arelin.Thing.set_pos 
      |this;
      |F64.V3.add(pos, F64.V3.scale(F64.mul(mov, boost), pad));
    // Decreases duration of all buffs, removes from list if dur=0
    let this = Arelin.Thing.update_buff_dur(this)
    // Integrates position with knockback
    let pos = Arelin.Thing.get_pos(this)
    let knk = Arelin.Thing.get_knk(this)
    let wei = Arelin.Thing.get_wei(this)
    let new_pos = F64.V3.add(pos, knk)
    let knk_len = F64.V3.len(knk)
    let new_knk = 
      case F64.gtn(knk_len, F64.0):
      | #true#
        let force = F64.max(F64.sub(knk_len, wei), F64.0)
        F64.V3.scale(force, F64.V3.norm(knk));
      | #false# knk;
    let this = Arelin.Thing.set_pos(this)(new_pos)
    let this = Arelin.Thing.set_knk(this)(new_knk)
    // Calls the transaction function
    let fun = Arelin.Thing.get_fun(this)
    let this = fun(this)
    // Calls the interaction function with all other things
    let this = List.foldr<><>(this, intr, others)
    // Increments tik counter
    let tik  = Arelin.Thing.get_tik(this)
    let this = Arelin.Thing.set_tik(this, F64.add(tik, F64.1))
    // Spawns children
    let this_chi = Arelin.Thing.get_chi(this)
    let chi_init = ((chi) 
      Arelin.Thing.get_fun(chi)(chi)
    ) :: Arelin.Thing -> Arelin.Thing
    let chi_list = List.map<><>(chi_init, this_chi)
    let this = Arelin.Thing.set_chi(this, List.nil<>)
    // Keeps inside map
    let this_pos = Arelin.Thing.get_pos(this)
    let pos_x = F64.V3.get_z(this_pos)
    let pos_y = F64.V3.get_y(this_pos)
    let pos_z = F64.V3.get_z(this_pos)
    let new_x = F64.min(F64.max(F64.parse("-256"))(pos_x))(F64.parse("256"))
    let new_y = F64.min(F64.max(F64.parse("-160"))(pos_y))(F64.parse("160"))
    let new_z = F64.min(F64.max(F64.0)(pos_z))(F64.parse("256"))
    let this  = Arelin.Thing.set_pos(this, F64.V3.new(new_x, new_y, new_z))
    // Bounds HP
    let dmg = Arelin.Thing.get_dmg(this)
    let mhp = Arelin.Thing.get_mhp(this)
    let new_dmg = F64.max(F64.0, F64.min(mhp, dmg))
    let this = Arelin.Thing.set_dmg(this)(new_dmg)
    // Dies when 0 is 0
    let sid = Arelin.Thing.get_sid(this)
    let dmg = Arelin.Thing.get_dmg(this)
    let mhp = Arelin.Thing.get_mhp(this)
    let no_hp = Bool.false
      // Bool.and(F64.gtn(sid)(F64.0))(F64.gte(dmg)(mhp))
    let die = Arelin.Thing.get_die(this)
    let xs = 
      case Bool.or(die, no_hp): 
      | #true#   res;
      | #false#  List.cons<>(this, res);
    List.concat<>(chi_list, xs)
  ) :: Arelin.Thing -> 
       List(Arelin.Thing) ->
       List(Arelin.Thing) ->
       List(Arelin.Thing)
  let things_id = ((x) x) :: List(Arelin.Thing) -> List(Arelin.Thing)
  get stage     = gm
  let stage_nil = List.nil<>
  let new_stage = Arelin.fold_with_context<><>(stage_nil, tick, stage, things_id)
  Arelin.Game.new(new_stage)
