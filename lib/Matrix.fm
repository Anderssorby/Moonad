// An attempt at a matrix library
T Matrix <A: Type> ~ (rows : Nat, cols : Nat)
| Matrix.new<rows: Nat, cols: Nat>(vec: Vector(Vector(A, cols), rows)) ~ (rows, cols);

//| Matrix.new(rows: Nat, cols: Nat) ~ (rows, cols);
Matrix.fill<A : Type>(value : A, rows: Nat, cols: Nat): Matrix(A, rows, cols)
    let row = Vector.fill<A>(cols, value)
    let rows_vec = Vector.fill<Vector(A,cols)>(rows, row)
    Matrix.new<A, rows, cols>(rows_vec)


Matrix.show<A : Type, rows : Nat, cols : Nat>(f : A -> String, m : Matrix(A, rows, cols)): String
  case m:
    | Vector.show<Vector(A,m.cols), m.rows>(Vector.show<A, m.cols>(f), m.vec);
    : String;

Matrix.test: IO(Unit)
  do IO {
    let m = Matrix.fill<Nat>(10,2,2);
    IO.print(Matrix.show<Nat,2,2>(Nat.show, m));
  }


Matrix.add<r : Nat, c : Nat>(m1: Matrix(Nat, r, c), m2: Matrix(Nat, r, c)): Matrix(A, r, c)
  def rec<r : Nat, c : Nat>(vec1: Vector(Vector(Nat, r, c)), vec2: Vector(Vector(Nat, r, c))): Vector(Vector(Nat, r, c)))
    case vec1:
    | Vector.nil<Nat>;
    | case vec2:
      | Vector.nil<Nat>;
      | Vector.ext<Nat>(head: Vector.add(vec1.head, vec2.head), tail: rec<vec1.size,vec2.size>(vec1.tail, vec2.tail));;
  case m1:
  | Matrix.new(vec1) =>
    case m2:
    | Matrix.new(vec2) =>
      Matrix.new<Nat, r, c>(vec: rec<r, c>(vec1, vec2))

