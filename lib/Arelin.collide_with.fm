// Checks if two boxes collide, returns outwards vector
Arelin.collide_with(
  a_pos : F64.V3,
  a_dir : F64.V3,
  a_box : Arelin.Game.Hitbox,
  b_pos : F64.V3,
  b_dir : F64.V3,
  b_box : Arelin.Game.Hitbox
) : Maybe(F64.V3)
  case a_box:
  | #nbox# Maybe.none<>;
  | #cbox#
    case b_box:
    | #nbox# Maybe.none<>;
    | #cbox#
      let dst = F64.V3.dist(a_pos, b_pos)
      let rad = F64.add(a_box.rad, b_box.rad)
      case Bool.and(F64.gtn(dst, F64.0), F64.ltn(dst, rad)):
      | let out_dir = F64.V3.norm(F64.V3.sub(a_pos, b_pos))
        let out_vec = F64.V3.scale(F64.sub(rad, dst), out_dir)
        Maybe.some<>(out_vec);
      | Maybe.none<>;;
    | #pbox#
      let nil = Maybe.none<>
      let cons = ((segment) (result)
        case result:
        | #none# 
          case segment:
          | let dst = F64.V3.point_segment_dist(a_pos, segment)
            let rad = a_box.rad 
            case F64.ltn(dst, rad):
            | #true#
              let out_dir = 
                F64.V3.rot_90(F64.V3.norm(F64.V3.sub(segment.a, segment.b)))
              let out_vec = F64.V3.scale(F64.sub(rad, dst), out_dir) 
              Maybe.some<>(out_vec);
            | #false# Maybe.none<>;;
          ;
        | #some# Maybe.some<>(result.value); 
      ) :: F64.Segment -> Maybe(F64.V3) -> Maybe(F64.V3)
      let segs = F64.V3.polygon_to_segments(b_pos, b_dir, b_box.pts)
      List.foldr<><>(nil,cons,segs);;
  | #pbox# Maybe.none<>; // TODO